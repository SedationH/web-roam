## 为什么要研究数据的表示和存储

世界的信息很多是连续的，通过IO设备将信息离散化才能存入计算机，出于物理实现和计算方便考虑，使用二进制进行信息编码。

数据的编码需要规范化，来方便计算机的计算和传输。



底层来看，基本的数据类型分为

1. 数值型数据  <--- 本节重点研究
2. 非数值型数据(逻辑、位操作 ｜ 字符处理指令)



规定：

- X 代表真值 指 外界想要映射到计算机上想表示的值的大小
- [X]m 表示以m方式实现的**机器码**
  - [X]原 原码
  - [X]补 补码



## 进制转换

2 <-> 8|16|10

10 <-> 2|8|16

2 进制是机器码的实现形式

10进制是我们平常生活习惯的方式

16 ｜ 8 进制是为了便于显示和表示2进制数字，因为可以 用一个 16｜8 进制数字表示4｜3 **个**二进制数字，缩短表示长度



八进制： 123O

16进制： 123H | 0x ACF

二进制 : 1001B

**现实中的精确值可能无法用2进制（机器码）的形式精确表示【小数】**

## 浮点数的表示

理论根据： 

任意一个十进制数N可以写为

N = 2^e*M 

M称为浮点数的尾数(定点小数)，e为浮点数的指数（定点整数）（阶码）

除此之外，再加一个符号位置，这样的模式就是计算机底层表示浮点数的逻辑

![image-20201003202411104](http://picbed.sedationh.cn/image-20201003202411104.png)

## 编码（重点在补码

## 原码 

通过最高位定为符号位置解决正负问题

0 的表示不唯一 1000 | 0000

加减不统一



## 补码

**重要概念：**在一个模系统中，一个数除以“模”后的余数等价

12模系统中  (8是 -4对模12的补码) | (-4的模12补码等于8)

8 - 4 === 8 + 8 在模系统中，结果都要再取模



通过规范计算机的数值表示，计算机的运算器恰好就是一个模运算系统

overflow -> 取模

如规定四位来存储数字

[0111]原 + [1001]原 === [0111]补 + [1111]补 = [0110]补 === [0110]原

补码统一执行加和运算，超出位直接溢出不予考虑，相当于自动进行了取模操作，对于上述规范为4位来存储数字的情况，相当于取模2^4,满足设计要求



补码的设计是为了统一加减法，核心是处理掉有关负数的运算

在 2^4 = 8 的模系统中 X = -3 => [1011]原 => [1101]补

做法

1. 除了最高符号为，各位取反+1
2. 从右至左，保持第一个1不变，后面的全部取反，不包括符号位置
3. 形象来看，-3的补码把-号纳入数字之中，整体对外表现为加号
   - 1-3 => 1+5
   - [0001]y - [1011]y => [0001]y + [0101]y xxx
   - [0001]b + [1101]b => [1110]b





我理解了这个计算，还是感觉好神奇，不知如何证明这个合理，符号位与模运算配合的刚刚好



另外在[X]b转X 的时候，可以把最高位置视为模系统-M（如-8），再加和别的位置



### 移码

即在每个数值上加一个偏置常数，为了简化大小比较【浮点数对阶操作】

如4位规范表示下

n = 4 

bias 2^(n-1) =  8

-8 ->  [0000]y

-7 ->  [0001]y

7 -> [1111]y



注意IEEE 745标准里 bias取 ` 2^(n-1) -1` btw? 我也没想明白

