## 构建复杂程序

考虑的要复用代码，我们通常把常用的操作封装为一个函数，通过一个又一个函数进行组合，我们就能逐步构建较为复杂的程序。

无论是for 还是 函数，这都是在高级语言层面的指令封装，在具体传达给处理器执行的时候，还是要变为特定的指令让处理器可以识别和执行

深入指令的实现来理解这个过程



## 循环和分支

- for -> 

  - jump loop:
  - loop:

  > jump 指令直接操作 PC 指针，但是很多 CPU 会抢先执行下一条指令，因此通常我们在 jump 后面要跟随一条 nop 指令，让 CPU 空转一个周期，避免 jump 下面的指令被执行

- 分支运算

  - if 从上至下依次判断 每次都有寄存器的结果进行比较
  - switch 通过数学关系映射指令所处位置

## 函数

一个函数具有一下特点

1. 可以传入参数
2. 可以执行规划好的代码
3. 可以返回值



🌰

```c++
int add(int a, int b){
  return a + b;
}
```

```指令
add:
load $a -> R0
load $b -> R1
add RO R1 R2
store R2 -> $r

如果要调用这个函数，就是
jump add
```

可以参数如何传递给函数？返回值如何传递给调用者？

机器通过维护栈数据结构的寄存器 `Stack Pointer`，其间有个栈指针不断指向栈顶（可以写入数据的位置）

为了保证先清除掉参数，跳回返回的地址，获取返回值，我们对数据位置如下安排

1. 参数 ...
2. 返回地址
3. 返回值

```指令
指令细节看不大明白，能看明白的就是说
注意分配好相对位置，利用SP进行间接寻址
```

宏观上看

如果执行的是

```c++
int sum(int n){
  if(n == 1) {return 1;}
  return n + sum(n-1);
}
```

|    n = 100     |
| :------------: |
| return address |
|  return value  |
|     n = 99     |
| return address |
|  return value  |
|     n = 98     |
| return address |
|  return value  |
|      ...       |

## Class

Class 分为两个部分

1. 属性
2. 方法



class 有一个特殊的方法叫作构造函数，它会为 class 分配内存。构造函数执行的时候，开始扫描类型定义中所有的属性和方法。

- 如果遇到属性，就为属性分配内存地址；

- 如果遇到方法，方法本身需要存到正文段（也就是程序所在的内存区域），再将方法的值设置为方法指令所在的内存地址。

关于this的简单实现

构造函数创建实例，能够拿到实例的地址，那么每次访问实例的方法的时候，把实例地址作为函数的参数传入就好



## QA

如何把递归解决转换为迭代解决

递归是系统在帮我们维护栈结构，想要自己迭代搞，就写个stack维护就好了

```c++
int fib(int n){
  if(n == 1 || n==2) {return n;}
  return fib(n-1) + fib(n-2);
}
```

