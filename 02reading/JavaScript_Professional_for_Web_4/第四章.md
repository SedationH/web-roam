## 第四章

### 原始值和引用值

变量的数据类型

- primitive value
- reference value

变量的访问

- 值
- 引用

传参方式

- 按值传递

JS不允许直接访问内存位置  no `&bar`

c++中有引用传递的方式

```c++
// difine
int foo(int & a)
  
// invoke
int a = 1
foo(a)
```

> **值传递：**
>
> 形参是实参的拷贝，从数据传递的角度，值传递的方式是单向的(实参 -> 形参)
>
> 即对形参的操作无法影响到实参
>
> **引用传递：**
>
> 形参相当于实参的alias，对形参的操作会被处理为间接寻址，从而影响到实参

```c++
#include <iostream>
using namespace std;
//值传递
void change1(int n)
{
  cout << "值传递--函数操作地址" << &n << endl; //显示的是拷贝的地址而不是源地址
  n++;
}

//引用传递
void change2(int &n)
{
  cout << "引用传递--函数操作地址" << &n << endl;
  n++;
}
//指针传递
void change3(int *n)
{
  cout << "指针传递--函数操作地址 " << n << endl;
  *n = *n + 1;
}
int main()
{
  int n = 10;
  cout << "实参的地址" << &n << endl;
  change1(n);
  cout << "after change1() n=" << n << endl;
  change2(n);
  cout << "after change2() n=" << n << endl;
  change3(&n);
  cout << "after change3() n=" << n << endl;
  return 1;
}

实参的地址0x7ffeeac784f8
值传递--函数操作地址0x7ffeeac784bc
after change1() n=10
引用传递--函数操作地址0x7ffeeac784f8
after change2() n=11
指针传递--函数操作地址 0x7ffeeac784f8
after change3() n=12
```

从c的角度看js，js的处理相较于c对数据的操作上包了一层抽象

1. 除去了引用传递参数，仅保留值传递

2. 对数据的操作，自动根据数据类型进行值访问或者引用访问(*foo)具体的值
   1. 具体来讲如果不自动封装引用访问的处理，那么拿到的则是指针，📦的效果就是看到primitive value is address, so via *address to get value。

> 编译的角度来阐述它们之间的区别：
>
> 程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

[上述内容参考](https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html)



ECMA-262 规定，任何实现内部[[Call]]方法的对象都应该在 typeof 检测时返回"function"

typeof null === 'object'

instace instanceof Class



### 执行上下文和作用域

#### 整体把握

执行上下文 -> Execute Context (EC)

这是一个环境，代表执行的时候能拿到什么  变量|函数｜this也算个特殊的变量吧

啥时候创建EC ?

1. 全局执行代码
2. 函数调用
3. eval执行

这个是在执行的时候才有意义，所以遇到能够执行的代码就要准备这个EC

代码的执行，函数的调用，就是通过在Execution Context Stack中进栈出栈来维护执行



>  想太多实现细节让人头秃，从现象把握

这个执行上下文具体的实现呢，有动态的特点，也有静态的特点

动态集中体现在this上。

静态集中体现在作用域链上。



作用域链采用静态作用域，或者说为词法作用域。 [相关参考](https://github.com/mqyqingfeng/Blog/issues/3)

一个函数能拿到什么变量，是有创建函数的context来决定的。

对比理解，动态作用域是在执行过程中才确定能拿到什么变量的。

```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar(); // 1
```

作用域链的末尾是runtime所提供的环境

web -> window

#### 可能会用到的细节

作用域链是可以增强的，相当于在作用域链开始增加一个可查找的空间进行查询

- catch 块
- with 语句 没有具体场景提供理解

```js
with(location) {
  var url = href + qs
}

var url = location.href + location.qs
```

var 声明的变量自动添加到最接近的上下文



标识符查找 缩短查找的链路 能查的更快

通过const let可以让v8优化执行



## 垃圾回收机制

**整体把握** 

js有的内存是自动管理的

管理就是管理内存中那些要用哪些不用

怎么管理呢？标准是什么呢？

用得着的不清理，不用的就扔了呗，用的多的缓存下，用的少的不管呗

具体实现

- 标记清理
- 引用计数 循环引用让这个算法拉垮了

为啥要理解这个？

因为写的不好的js会造成内存泄漏，会引发性能问题

啥是内存泄漏？

就是该释放的没释放，该清除的没清除

常常是闭包带来的，js能够返回函数，还有回调，这些之中引用着其context中的变量，导致引擎无法及时清除。

性能的问题看不大懂



注意不用了别忘了解除引用就好了 foo = null

