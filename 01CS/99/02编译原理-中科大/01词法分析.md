## 任务

**词法分析阶段的任务就是把字符流转换为记号流**

即将source code -> token

source 与使用的语言密切相关 ASCLL Unicode ...



## 实现方法

- 手工编码
  - 相对复杂
  - 流行的GCC，LLVM都是手工编码进行实现的
  - 细节可控
- 词法分析器生成器
  - 编码少
  - 细节难控制



## 转移图

![image-20201009111013848](http://picbed.sedationh.cn/image-20201009111013848.png)

⭕️里放个数字，表示的是第几个状态，◎的表示的是可作为结束的状态



编码无非就是匹配和分支语句

这里不太明白rollback是干什么的



对于关键字判断，可以在转移图中加入分支，亦可以构造关键字生成的哈希表来进行查询

步骤如下

1. 准备关键字构成的哈希表H
2. 对所有的标识符和关键字，统一通过标识符的转移图进行识别
3. miss -> 查H

可以合理的构建哈希（完美哈希），让查询复杂度 -> O(1)



## precondition

### Regular Expression

方便我们进行模式匹配

在生成器方案中

我们只用编写声明式的规范，在通过相关工具🔧(e.g. flex ... )生成所需的词法分析器

RE就是为✍️这个声明式的规范做准备的



对于给定的字符集∑ = {c1, c2, ..., cn}

归纳定义

- 空串ℇ is RE
- any c ∈ ∑, c is RE
- if m & n is RE,then below also
  - M|N = {M∪N}
  - MN = {mn | m∈ M, n∈ N}
  - closure M* = {ℇ, M ,MM, ...}



这里引入语法糖的概念，在计算机的指令层级，所有指令都可以通过赋值和jump实现 

我们有许多计算机指令，在指令上又搭建了需要高级语言，这都是语法糖的封装



ES还有好多语法糖，自己查询



### 描述状态的工具 FA(有限状态自动机)

FA 探寻的就是 什么串是可接受的

M = ( ∑, S, q0, F, 状态转移)



确定状态的有限自动机DFA，要识别的字符，最多只有一个状态可以转移

![image-20201009113537122](http://picbed.sedationh.cn/image-20201009113537122.png)

非确定的优先状态自动机NFA，就是要识别的字符，有多个状态可以转移 NFA

编码复杂，需要回溯



![image-20201009113600047](http://picbed.sedationh.cn/image-20201009113600047.png)



通常transform  NFA  to DFA 然后再build