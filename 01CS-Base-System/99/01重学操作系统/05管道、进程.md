## 进程

应用的执行是在内存中形成相应的副本，这个副本就是进程

所以，对于进程的定义：进程是应用的副本

进程的效用：进程是操作系统分配资源的最小单位

这里先简单认识下进程和相关操作，主要中心放在pipeline上

```zsh
$ ps -f
  UID   PID  PPID   C STIME   TTY           TIME CMD
  501  2487  2486   0  8:49PM ttys000    0:00.10 -zsh
  501 76584 76583   0 Fri10AM ttys001    0:01.69 /bin/zsh -l
  501  9647  1310   0 10:53AM ttys004    0:00.03 /Applications/iTerm.app/Contents/MacOS/iTerm2 --server /bin/zsh
  501  9648  9647   0 10:53AM ttys004    0:00.15 /bin/zsh

```

pid 是进程的唯一标识

## Pipeline

[Pipe, Grep and Sort Command in Linux/Unix with Examples](https://www.guru99.com/linux-pipe-grep.html#:~:text=The%20Pipe%20is%20a%20command,symbol%20'%7C'%20denotes%20a%20pipe.)

pip是建立在IO的基础上，用于连接上一个的输出和下一个的输入



### 标准输入，输出，错误流

每个进程拥有自己的标准输入，输出，错误流

这几个标准流说起来很复杂，但其实都是文件。

- 标准输入流（用 0 表示）可以作为进程执行的上下文（进程执行可以从输入流中获取数据）。

- 标准输出流（用 1 表示）中写入的结果会被打印到屏幕上。

- 如果进程在执行过程中发生异常，那么异常信息会被记录到标准错误流（用 2 表示）中。



### 重定向

`ls -l`结果默认写入标准输出流，进而被打印。

这个数据流向可以通过重定向符号进行改变

```zsh
$ ls -l > out # 覆盖重定向
$ cat out
total 8
-rw-r--r--  1 sedationh  staff  30 Oct 16 20:31 comman
-rw-r--r--  1 sedationh  staff   0 Oct 17 11:02 out
prw-r--r--  1 sedationh  staff   0 Oct 16 20:34 pip1
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_x.a
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_y.a
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_z.a
$ ls >> out # 追加重定向
$ cat out
total 8
-rw-r--r--  1 sedationh  staff  30 Oct 16 20:31 comman
-rw-r--r--  1 sedationh  staff   0 Oct 17 11:02 out
prw-r--r--  1 sedationh  staff   0 Oct 16 20:34 pip1
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_x.a
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_y.a
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_z.a
comman
out
pip1
prifix_x.a
prifix_y.a
prifix_z.a
# 上述只改变了标准输出流的数据流向 没有改变标准错误流
$ ls &>> out
$ cat out
total 8
-rw-r--r--  1 sedationh  staff  30 Oct 16 20:31 comman
-rw-r--r--  1 sedationh  staff   0 Oct 17 11:02 out
prw-r--r--  1 sedationh  staff   0 Oct 16 20:34 pip1
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_x.a
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_y.a
-rw-r--r--  1 sedationh  staff   0 Oct 16 20:26 prifix_z.a
comman
out
pip1
prifix_x.a
prifix_y.a
prifix_z.a
zsh: command not found: lsl
```



### 管道

**管道和重定向很像，但是管道是一个连接一个进行计算，重定向是讲一个文件内容定向到另一个文件，两者经常结合使用**

Linux 中的管道也是文件，有两种类型的管道：

1. 匿名管道（Unnamed Pipeline），这种管道也在文件系统中，但是它只是一个存储节点，不属于任何一个目录。说白了，就是没有路径。

2. 命名管道（Named Pipeline），这种管道就是一个文件，有自己的路径。

> 管道具有 FIFO（First In First Out），FIFO 和排队场景一样，先排到的先获得。所以先流入管道文件的数据，也会先流出去传递给管道下游的进程。



从使用场景来看管道

```zsh
# 文件名排序
$ ls | sort
comman
out
pip1
prifix_x.a
prifix_y.a
prifix_z.a

# 去重复
$ cat example
apple
banana
apple
banana
orange

$ cat example | sort | uniq
apple
banana
orange
# 筛选文件
$ find ./
./
.//out
.//example
.//prifix_x.a
.//pip1
.//dir
.//dir/example2
.//dir/example1
.//prifix_y.a
.//comman
.//prifix_z.a

$ find ./ | grep example
.//example
.//dir/example2
.//dir/example1

# 一个文件中有多少行
$ wc -l example
       5 example
       
# 中间结果保存
$ find ./ | tee temp | grep example | cat # 在函数式编程的范式中 tee产生了副作用
.//example
.//dir/example2
.//dir/example1

$ cat temp
./
.//out
.//example
.//prifix_x.a
.//pip1
.//dir
.//dir/example2
.//dir/example1
.//prifix_y.a
.//comman
.//prifix_z.a
# xargs 重命名以.a结尾的文件，加prefix 不使用样板代码
$ ls | grep \.a | xargs -I $ echo "mv $ prefix_$"
mv comman prefix_comman
mv example prefix_example
mv x.a prefix_x.a
mv y.a prefix_y.a
mv z.a prefix_z.a
```

### 管道文件

上面其实都在使用匿名管道，用｜就可以创造和使用。

> 匿名管道也是利用了文件系统的能力，是一种文件结构。当你学到模块六文件系统的内容，会知道匿名管道拥有一个自己的inode，但不属于任何一个文件夹。



还有一种管道叫做Named Pipeline 

命名管道是要挂到文件夹中的，因此需要创建。用mkfifo指令可以创建一个命名管道，下面我们来创建一个叫作pipe1的命名管道

```zsh
$ mkfifo pip1
$ cat pip1 &
[1] 12967

$ echo "x" >> pip1
x
[1]  + 12967 done       cat pip1

```

$表示指令在后台执行，不阻塞用户输入