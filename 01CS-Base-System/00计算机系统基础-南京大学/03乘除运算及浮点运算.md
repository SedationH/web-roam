一个重要的认识，我们通过高级语言写的程序是要通过编译解析的，这个过程可能存在指令的优化。

这里就是很多时候我们觉得功能是一样的，但为什么结果不一样的缘由。

代码不是直接跑在机器上的，有编译器这个中介可能对代码进行修改。

## 整数乘法

两个n位的数字相乘，结果应该是2n位的数字，计算机因为位数的限制，只取低n位。这样的结果就不一定是正确值了。



如何在语言层面进行检测呢？

```c++
z = x*y
if(!x || z/x==y){
  return z
} else {
  return 'Overflow'
}
```

因为有无符号整数和带符号整数，符号位置的处理无法像加法那么统一

区分为无符号乘法器和带符号乘法器



![image-20201022092559843](http://picbed.sedationh.cn/image-20201022092559843.png)

注意 -3 * -2 如果使用无符号那样直接称，得出的答案是10110110 从这里可以看出，有符号乘法器和无符号乘法器的处理是不一致的



所以，指令方面，有无符号数乘指令、带符号数乘指令

乘法指令不生成溢出标志，编译器可以使用2n位乘积来判断是否溢出。



一个因为整数溢出产生的漏洞

```c++
int copy_array(int* array,int count) {
  int i;
  // 在堆申请一块内存
  int *my_array = (int*) malloc(count * sizeof(int));
  if(my_array == NULL) return -1
  for(i=0;i<count;i++){
    my_array[i] = array[i]
  }
}
```

问题的产生在于 `count * sizeof(int)` 溢出导致事实上没有这么多这么多空间被分配，引起heep中的内存被破坏



计算机执行乘法指令是相对费时的

所以对于变量与常数的乘法运算，编译器会进行优化

使用移位、加法的组合来代替乘法运算



20 = 16+4 = 2^4 + 2^2

2*20 -> (x<<4)+(x<<2)



即使替代了，一样会溢出，结果都是一样的。



## 整数除法

对于带符号整数来说，n位整数除以n位整数，除了-2^(n-1)/-1 = 2(n-1)会发生溢出外，别的情况都不会产生溢出

商的绝对值都是小于等于被除数的

在处理结果的时候，除不完的情况都是向0靠近的

e.g. 

- -7 /3 -> -2
- 7/3 -> 2

x / 0 需要调用操作系统进行一异常处理



这里也要注意编译器对代码的修改

```c++
// code segment 1
int a = 0x8000000; // 1000....00
int b = a / -1;
printf("%d",b);
// -2^(32-1)

// code segment 2
int a = 0x8000000; // 1000....00
int b = a / -1;
int c = a / b;
printf("%d",c);
// error : Floating point exception
```

seg1不报错的原因是 -1 被优化为取负指令



与乘法一样的逻辑，优化变量与常量之间的除法运算

无符号： 逻辑右移

带符号：算数右移



能够整除

12 / 4 = 3 : 0000 1100 >>2 = 0000 0011

-12 / 4 = -3 : 1111 0100 >> 2 = 1111 1101



![image-20201022110158612](http://picbed.sedationh.cn/image-20201022110158612.png)

自己拿笔算一遍就知道了 先尝试不使用偏移看下结果



挺有趣

![image-20201022110600142](http://picbed.sedationh.cn/image-20201022110600142.png)

