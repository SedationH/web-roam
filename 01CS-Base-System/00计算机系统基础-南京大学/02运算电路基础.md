## 数字逻辑电路基础 

### 布尔代数

从 [00数据的表示和储存.md](./00数据的表示和储存.md)大致了解数据在在计算机上的存储形式，都是0，1的二进制数据

仅有存储还不够，基于这些存储实现运算，计算机才能够执行

关于0和1的数学运算体系称为布尔代数

最基本的逻辑运算有

- (^ , ∙, ADN) 与 
- (⋁, +, OR) 或
- 非

### 逻辑电路

![image-20201020092912802](http://picbed.sedationh.cn/image-20201020092912802.png)

👆是一位的，对于n位运算，只是重复使用而已

![image-20201020093043841](http://picbed.sedationh.cn/image-20201020093043841.png)



有了上述的元件，我们可以组合出各种电路了

- 根据电路是否具有存储功能
  1. 组合逻辑电路：没有存储功能，其输出仅依赖当前输入
  2. 时序逻辑电路：具有存储公鞥，依赖输入和当前存储单元的状态
- 利用基本逻辑门电路可以构成一些具有特定功能的组合逻辑部件(功能部件)
  - 译码器、编码器、多路选择器、加法器
- 分析逻辑
  1. 拿到真值表
  2. 确定逻辑表达式
  3. 实现逻辑电路



### 常见功能部件

多路选择器

全加器 -> n位加法器 -> n位带标志加法器 -> 算数逻辑部件(ALU)

![image-20201020094027129](http://picbed.sedationh.cn/image-20201020094027129.png)

![image-20201020094051795](http://picbed.sedationh.cn/image-20201020094051795.png)

![image-20201020094107406](http://picbed.sedationh.cn/image-20201020094107406.png)



![image-20201020094119790](http://picbed.sedationh.cn/image-20201020094119790.png)




值得注意的点：在 n位带标志加法器 中实现了补码运算，**重点理解[-X]补计算机是如何处理的**

![image-20201020094217222](http://picbed.sedationh.cn/image-20201020094217222.png)

![image-20201020094006586](http://picbed.sedationh.cn/image-20201020094006586.png)



![image-20201020094206319](http://picbed.sedationh.cn/image-20201020094206319.png)



很不想copy课件，但很多点都很重要QAQ，而且总结的忒好了



至此，可知：

**计算机中的所有运算都是相应的运算电路完成的，而这些运算电路是由基本的门电路实现的。**

## 从C表达式到逻辑电路

高级语言程序中表达式的各种运算，会被编译器转换为相应的运算指令，再由CPU执行这些运算指令。

![image-20201020140852794](http://picbed.sedationh.cn/image-20201020140852794.png)



## 整数加减运算

C语言中的整数有

- 带符号整数
- 无符号整数

地址、指针通常被说明为无符号整数，因此有对无符号整数的加减需求

无论是无符号整数还是带符号生疏的加减电路，都是一样的，基于带标志加法器实现。

计算机中的加法器，因为只有n位，所以天然形成了模2^n运算系统



所有运算电路的核心认识：

1. 计算机中的所有运算都基于加法器实现
2. 加法器不知道所运算的是带符号数还是无符号数
3. 加法器不判定对错，总是取低n位作为结果，并产生标志信息



条件标志位（也叫：条件码CC）

- ZF 零标志
- OF 溢出标志 (Tip: 虽然这里叫做溢出标志，但是对于有符号和无符号的具体溢出判断情况是不一致的)
- CF 进/借位标志 CF = Cout⊕Cin
  - 这里的理解参考整数加减部件实现中**Sub和多路选择器的配合**
- SF 符号标志

这些条件标志会被记录到专门的寄存器中 -> 标志寄存器

这些在

if(x > y)这样的分支指令中就会用到



## 溢出情况讨论

- 加法 主要考虑溢出问题，计算机中的所有运算其实已经统一为加法了
  - 无符号加溢出条件：CF = 1 这里 sub = 0 cin = 0 CF = 1说明 Cout = 1可判断产生了溢出
  - 有符号溢出条件： OF = 1
    - 两个判断方法
      1. 相加符号不同则不会溢出，相同则判断加和后的结果和原来的参与运算的符号是否一致 （在硬件上实现较为麻烦）
      2. OF = Cn ⊕ Cn-1 这个出因从正负的角度考虑
         1. 正数 0111 + 0111 -> 1110  Cn 与 Cn-1 分别是 0 1 -> OF = 1 所以产生溢出
         2. 负数 1111 + 1111 -> 11110(-2) Cn 与 Cn-1 分别是 1 1 -> OF = 0 没有产生溢出
         3. 负数 1001 + 1001 -> 10010 Cn 与 Cn-1 分别是1 0 -> OF = 1产生溢出
         4. 可见这一统一设计同时可以判断补码形式下数据运算的溢出情况，而计算机中的有符号数正是由补码进行表示的
- 减法 用于比较大小

![image-20201020154453783](http://picbed.sedationh.cn/image-20201020154453783.png)

自己拿数据写一下就明白这个正确了

奇怪的是为什么是正确的

另外，对于无符号数不知道具体负号如何处理