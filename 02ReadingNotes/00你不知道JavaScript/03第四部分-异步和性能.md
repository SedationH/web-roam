## 异步：现在与将来



```js
setTimeout(() => {
  console.log(2)
}, 1000)

console.log(1)
```

可以把上述代码 分为两块



现在

```js
setTimeout(() => {
  ...
}, 1000)

console.log(1)
```



未来

```js
console.log(2)
```



一堆JS代码可以分成这样一个又一个的块，在js中，常见的块单位是函数





控制台打印出东西是一种IO，IO相较于代码执行速度而言，是一种低速的阻塞。

浏览器可能在这里用异步优化，从而可能打印出不是当前的结果，这一点在打印结构对象上可能出现。

比较好的方案是使用`JSON.stringfy()`



### 事件循环

如何协调多个块的执行

某些块可能在未来被调用（时间到、触发交互事件等等

引入事件循环

```js
const events = []

while (true) {
  // 每一次循环是一次tick
  if (events.length > 0) {
    const event = events.shift()

    event()
  }
}
```



### 并行线程

并行计算常用的工具就是进程和线程，可以代码意义上的同时，但不是指令意义上的。



事件循环机制中也有多个线程，但是将代码的执行仅仅放在一个线程上运行，其他线程是在辅助这个事件循环。



并行和事件循环在代码执行的粒度上，是完全不同的

并行 -> 某一句代码的交替

时间循环 -> 某函数块的交替



单线程循环是处理并发（宏观同时）的一种方式



### 竞态 处理



某个函数的执行需要满足一些情况

- 条件都满足 -> &&
- 只有第一个可以



## 回调

回调是JS中最基础的异步模式



### 顺序的大脑

我们的大脑在同一时间只能思考一件事情，看上去的多线程其实依赖于快速的上下文切换，整体表现为并发。



JavaScript的执行也是如此，只有一个主线程在执行代码，其他线程是在辅助，比如维护事件循环，查询某些事件。



回调的写法可能产生嵌套，但可以通过抽出函数的方式进行解决

真正麻烦的问题在于不好维护的控制流

大脑的思考方式是顺序的，阻塞式的，无法很好的映射到回调异步编码中。



### 信任问题

你写的代码的执行不由你控制



```js
function foo() {
  console.log('i am foo')
}

function trackFn(fn) {
  fn()
}

trackFn(foo)
```



trackFn是第三方的提供的代码追踪服务

foo是你的业务代码

控制反转 (inversion of control)



业务代码流的控制权就交付给了第三方，这样的控制反转可能造成信任链的完全断裂



### 风格

检查、规范函数的输入

信任、但要核实。



error-first

Node.js 中很多代码都是这样的风格

(err, ...args)



### 总结

回调作为JavaScript中最基础完成异步功能的工具

主要有两个问题

1. 不适应我们线性、阻塞式的大脑，控制流不好组织
2. 控制反转带来的信任问题



## Promise

现代的异步解决方案



### 再谈控制反转

在回调的方案中，我们将自己想要执行的代码交付其他代码执行，这里的核心诉求是我想要在我的代码和其他代码中建立合理的依赖关系

即 其他代码执行完了，调用我的代码。

那么让其他代码的完成通过事件告知我就好了，由我来决定下一步做什么



达到类似的效果

```js
function foo() {
  console.log('foo frist')
}

const fooOnFulfilled = () => {
  console.log('foo onFulfilled')
}

const fooOnRejected = () => {
  console.log('foo onRejected')
}

foo.on('onFulfilled', fooOnFulfilled)

foo.on('onRejected', fooOnRejected)
```

上面的编码方式还不能用，需要引入事件对象evt



```js
function foo() {
  console.log('foo frist')

  return evt
}

const fooOnFulfilled = () => {
  console.log('foo onFulfilled')
}

const fooOnRejected = () => {
  console.log('foo onRejected')
}

const evt = foo()

evt.on('onFulfilled', fooOnFulfilled)

evt.on('onRejected', fooOnRejected)

// 或者包装一下
const fooOnFulfilled = evt => {
  evt.on('onFulfilled', fn)

  const fn = () => {
    console.log('foo onFulfilled')
  }
}

const fooOnRejected = evt => {
  evt.on('onRejected', fn)

  const fn = () => {
    console.log('foo onRejected')
  }
}
```



foo函数并不需要知道fooOnFulfilled  、 fooOnRejected依赖着自己

利用事件订阅的方式（Promise本身就是个对事件订阅模式的应用），完成特定情况的告知

告知什么，和告知行为的规范化 -> Promise

> **关注点分离**（Separation of concerns，SoC）w



拉回前面电视机 display 和 回调信任的那个场景

其实我trackFn如果不resolve，我的foo也无法执行

```js
function foo() {
  console.log('i am foo')
}

function trackFn() {
}

trackFn().then(foo)
```

但相较于原来的优势是什么？

是我来制定foo的运行和怎么运行（不会出现购买五次的情况了

从事件通知的角度来说，那里emit onFulfilled 五次 还是会运行五次

但Promise的规范让这个事件不能这么通知，这也就是我上面所说的规范化



确定好通知规范后，啥时候用就由使用的人来决定了

> 书中提是反转的反转，这里不太认可



### 一致化现在和将来

```js
function getFiveAfterXOneSeconds(x) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(x)
    }, 1000)
  })
}

getFiveAfterXOneSeconds(1).then(console.log)
Promise.resolve(2).then(console.log)
console.log(3)
// 3 2 1
```

不管是立马可以得到的值（2

还是存在于未来的值（1

都被滞后了（先打印的3



不仅值是如此，错误也是如此

try catch 无法捕获异步的错误

在Promise中，无论同步的还是异步的，都被放到了异步