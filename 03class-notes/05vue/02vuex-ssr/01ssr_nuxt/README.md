前置知识

渲染就是把模版和数据组合到一起 ejs...

传统两个实现

- 服务端渲染
  - 前后端Coupling
  - 服务端压力大
  - 用户体验不如spa
- 客户端渲染
  - 需要等待js解析完成才能看到页面，首屏加载时间过长
  - 不利于seo，dom是js生成的，搜索引擎处理不好



融合就解决了

![image-20201222211004705](http://picbed.sedationh.cn/image-20201222211004705.png)

用不用还是看业务需求

> 在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染(SSR) 可以帮助你实现最佳的初始加载性能。
> 事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。但性能在其次，不代表性能不重要



nuxt在vue上层套了一层，提供特殊的api，来实现同构渲染

https://nuxtjs.org/docs/2.x/get-started/directory-structure

感觉和过去使用的umi很相似，约定式，低配置

减少重复劳动，注意力集中于业务和需求

我想 这也是前端工程化的目的吧，当然还有业务的许多链路，这只是一个小流程



使用nuxt 完成 [realworld项目](https://github.com/SedationH/my-realworld/tree/frontends/nuxt)

学习了很多，实践很能锻炼人✨



deploy的过程也稍微记一下

```zsh
zip -r foo publish

ssh root@publicIP

scp foo.zip root@publicIP:/root
pm2 start yarn -- start
```

