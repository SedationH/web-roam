曾经自己写过一遍

参考小册手写系列

尽量使用新特性

## call apply bind

### apply bind

两者都是用来改变指向并且调用的，只是参数有些不同

```js
Function.prototype.myCall = function (obj, ...args) {
  obj = obj || globalThis
  obj.fn = this
  const res = obj.fn(...args)
  delete obj.fn
  return res
}

function getName(age1, age2) {
  console.log(this.name)
  console.log(age1, age2)
}

const foo = {
  name: 'foo',
}

getName()
getName.call(foo, 1, 2)
getName.myCall(foo, 1, 2)

```



```js
Function.prototype.myApply = function (obj, args) {
  obj = obj || globalThis
  obj.fn = this
  const res = obj.fn(...args)
  delete obj.fn
  return res
}

function getName(age1, age2) {
  console.log(this.name)
  console.log(age1, age2)
}

const foo = {
  name: 'foo',
}

getName()
getName.apply(foo, [1, 2])
getName.myApply(foo, [1, 2])
```



### bind

能够用返回this调整后的函数

还可以用来make a function with pre-specified initial arguments.



```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  return (...insideArgs) => {
    this.call(obj, ...[...args, ...insideArgs])
  }
}
```

但是之类没有解决 new 的问题

> The value to be passed as the `this` parameter to the target function `func` when the bound function is called. The value is ignored if the bound function is constructed using the [`new`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) operator. When using `bind` to create a function (supplied as a callback) inside a `setTimeout`, any primitive value passed as `thisArg` is converted to object. If no arguments are provided to `bind `, or if the `thisArg` is `null` or `undefined`, the `this` of the executing scope is treated as the `thisArg` for the new function.

```js
Function.prototype.myBind = function (obj, ...args) {
  obj = obj || globalThis
  return (...insideArgs) => {
    this.call(obj, ...[...args, ...insideArgs])
  }
}

function getName(age1, age2) {
  console.log(this.name)
  console.log(age1, age2)
}

const foo = {
  name: 'foo',
}

function myNew(constructor, ...args) {
  const obj = {}
  const res = constructor.call(obj, ...args)
  Reflect.setPrototypeOf(obj, constructor.prototype)
  return res instanceof Object ? res : obj
}

function Foo(name, age) {
  this.name = name
  this.age = age
}

const f1 = new (Foo.bind(foo, 'f1'))(1)
// const f2 = myNew(Foo.bind(foo, 'f2'))(2)
// console.log(f1, foo)
const f = () => {}
console.log(f.prototype)
```

还没处理好