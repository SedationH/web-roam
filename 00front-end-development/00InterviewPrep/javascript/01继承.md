## 先理解new

先要晓得new操作符的作用

1. 返回一个对象，构造函数上的this被固定到这个对象（实例）上
2. 构造函数返回primitive忽略，若返回对象则需进行处理
3. 创建出来的对象（实例）能够访问到构造函数的prototype

```js
function myNew(Con, ...arg) {
  // Con 是构造函数
  const obj = {}
  // 使用构造函数初始化对象
  const result = Con.apply(obj, arg)
  // 将构造函数的prototype绑定到创建的对象上
  Object.setPrototypeOf(obj, Con.prototype)
  // 经测试，如果构造函数的返回值如果是对象，就会返回构造函数中指定的返回值
  return result instanceof Object ? result : obj
}
function Foo(name, age) {
  this.name = name
  this.age = age
}
Foo.prototype.showInfo = function () {
  console.log(`name: ${this.name}\nage: ${this.age}`)
}
const foo = myNew(Foo, 'SedationH', '21')
foo.showInfo()
// name: Sedation
```



## 继承方式

https://github.com/mqyqingfeng/Blog/issues/16


想实现的效果 属性是自己的 方法是公用的

这样就在保持实例独立性的同时，能够使用更多方法

JS高级第四版 p.238

> ECMA-262把原型链定义为ECMAScript的主要继承方式。
>
> 其基本思想就是通过原型链继承多个引用类型的属性和方法。
>
> 重温一下构造函数、原型链和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。
>
> 如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。 => 原型链

```js
function Father() {
  this.father = true
}

Father.prototype.getFather = function () {
  console.log('father')
}

function Son() {
  this.son = true
}

Son.prototype = new Father()

const s = new Son()
console.log(s.constructor === Father) // ture !!
s.getFather() //father
```

